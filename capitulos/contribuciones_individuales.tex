\chapter{Contribuciones individuales}

\section{Héctor Laria Mantecón}
Decidir la versión de Pac-Man a utilizar fue bastante fácil ya que nuestro profesor Antonio nos recomendó una con bastantes buenas referencias, así que pudimos jugar todos en verano con ella para volvernos familiares. Cuando empezó el curso buscamos el \textit{framework} de Programación Evolutiva, probando primeramente con GEVA. Ninguno consiguió hacerlo funcionar porque usaba tecnología un poco obsoleta y era algo oscuro. Así que nuestro profesor Carlos nos presentó una segunda opción en la que estábamos de acuerdo los cuatro, JECO. Ésta era más simple, versátil y mejor organizada así que aunque todos hemos tenido que pelear y modificarla en algún momento, nos ha sido de mucha utilidad.

Teniendo eso resuelto, lo primero que hice fue encargarme del repositorio de código ya que yo era un poco más familiar con el uso de herramientas de versionado, desarrollo en ramas, \textit{issues}, uso de etiquetas y versiones, etc. Puse a disposición de los demás algunas páginas en la \textit{wiki} del repositorio sobre cómo borrar y fusionar ramas y demás. Tampoco fue la panacea, ya que aprendimos a las malas que el desarrollo paralelo es mejor dividirlo por \textit{features}, no por personas.

Una vez dominado y debido al buen funcionamiento que llevábamos, pensamos en ir un poco más allá y buscar una herramienta de gestión de proyectos más avanzada y que tuviera integración con nuestro repositorio de \textit{GitHub}. Sobre todo porque en ese momento había ciertas tareas que requerían de otras y no queríamos dejar a gente parada. Busqué e hice comparación de herramientas sobre todo con diagramas de \textit{Gantt} y encontré algunas pero de todas las que había no había ninguna que no fuese de pago. Al final llegó un momento en que tuvimos material suficiente como para que ninguno tuviese que estar esperando y dejamos la idea de estas herramientas a un lado.

En lo referente a la implementación, después de que Jorge Vieira conectara la versión del autómata con Pac-Man conseguí junto a él activar el multihilo para el algoritmo evolutivo y nos quedamos impresionados por el rendimiento que nos daba, ahora podíamos hacer uso de operadores más complejos y aumentar el tamaño de la evolución tardando incluso menos tiempo.

Más tarde, añadí soporte para funciones de \textit{fitness} en JECO para mayor modularidad y que nos fuera más fácil cambiar entre funciones, con vistas al futuro.

Cuando terminamos el autómata estaba claro que necesitábamos una definición mejor de gramática y una conexión mejor con la ejecución en Pac-Man. Era el único que no había dado fundamentos ni procesamiento de lenguaje, así que me propuse investigar y aprender sobre gramáticas, sacando al final la llamada gramática base. A la que además le pude meter las funciones en las que estaban trabajando los demás. Cuando la terminé tuvo muy buena afectación y me dieron \textit{feedback} para pulir ciertos detalles. Estoy muy contento con esa gramática porque es muy robusta y bien organizada, así que nos sirvió como base para todas las siguientes gramáticas que se hicieron, cumpliendo totalmente mi objetivo.

Después de que José Miguel implementara los árboles de decisión que íbamos a usar para ejecutar el controlador de Pac-Man, me ocupé de que JECO derivara programas de la gramática base para después pasar el string producido al constructor de árboles José Miguel. Corregimos los fallos que nos daba el \textit{parseo} y así finalmente habíamos conectado JECO con los árboles de derivación.

Seguidamente, hice el código para ejecutar esos árboles en Pac-Man y que devolvieran un movimiento cada vez que se le pedía desde el juego, cerrando así el círculo con el algoritmo evolutivo, al conectar los árboles de derivación con Pac-Man. Más tarde esta parte sería reescrita para usar una nueva implementación de árbol más clara.

Paralelamente al desarrollo del trabajo, me ocupé en solitario de crear una interfaz gráfica que fuera sencilla y cubriera todas nuestras necesidades. Si tuviera que hacerla de nuevo me negaría en rotundo a hacerla yo solo, lo distribuiríamos entre dos o entre los cuatro. Tuve la suerte de empezar en vacaciones de navidad pero fue un trabajo demasiado grande, tanto como para empezar como para mantenerla y actualizarla.

Tuve que modificar los algoritmos de JECO, los patrones que implementaba, hacer una arquitectura entera para hablar con todas las partes, investigar la librería gráfica de Java para que no se bloqueara la interfaz al evolucionar, además conseguir que el multiobjetivo siguiera funcionando a la vez, investigar librerías de dibujado de gráficas, investigar la implementación de Pac-Man para incrustar su ventana en la interfaz, sin que se bloqueara tampoco al ejecutar una partida ni al estar evolucionando, y un largo etcétera de problemas que surgieron más adelante.
En los últimos meses estaba tan ocupado que José Miguel me echó una mano para añadir ciertos detalles, como el selector de \textit{fitness} multiobjetivo.

Después de terminar los árboles llegó la hora de empezar a experimentar con multiobjetivo. Después de consultar y ver que JECO tenía soporte y los operadores necesarios para ello, me dispuse a mejorar la primera versión del soporte de \textit{fitness} que había hecho antes para que soportara varios \textit{fitness} a la vez, pasándole a JECO los resultados fácilmente.
En los últimos meses, gracias al logger que hizo Jorge Vieira pude tener suficientes datos para hacer varios análisis de los entrenamientos, además de sacar gráficas y estadísticas tanto para el artículo como la memoria. Usé \textit{Jupyter Notebook} y las librerías \textit{Pandas} y \textit{Seaborn} para ello.

Siguiendo con los análisis, debido a la naturaleza estocástica de los controladores de los fantasmas, necesitábamos tantos datos como fuera posible para paliar este efecto y poder hacer mediciones correctas. Por lo que hice un \textit{script} que corría miles de partidas y guardaba los datos. José Miguel me ayudó a manejar los datos y conseguimos las medidas de los mejores elementos de las evoluciones, con mucho mayor detalle que en el entrenamiento.

En definitiva, he aprendido mucho con este trabajo. Cómo trabajar en equipo (mucho más que en la carrera), cómo hacer las cosas, cómo no hacerlas, lo fácil que es acostumbrarse al buen trabajo de los compañeros y más. También he aumentado mis conocimientos Programación Evolutiva y, por lo menos yo, le he cogido el gusto a leer artículos de investigación.

\section{Jorge Sánchez Cremades}

\section{José Miguel Tajuelo Garrigós}

\section{Jorge Vieira Luna}
Cuando tuvimos claro el proyecto lo primero fue buscar junto a los compañeros los \textit{frameworks} que íbamos a usar, tanto para Pac-Man como para JECO. Decantarse por ``Ms. Pac-Man Vs. Ghost'' para Pac-Man fue fácil: Ha habido varias versiones, pero la única que se mantiene actualizada y para la que se hacen competiciones a día de hoy es esa.

El \textit{framework} de gramáticas evolutivas en cambio no estaba tan claro. Primero probamos bastante GEVA, tal vez por ser de los más famosos, pero personalmente no me gustó nada la estructura del código con vistas a integrarlo con Pac-Man. Sin embargo cuando tras leer y trastear con el código de JECO para mi estaba claro, con JECO no iba a haber problemas, así que fuí partidario de JECO que es lo que usamos al final. Hemos tenido sus más y sus menos con él, pero personalmente yo y creo que mis compañeros estamos bastante contentos con la decisión.

Una vez que tuvimos los \textit{frameworks} me ocupé de la integración entre ambos, para conseguir una primera versión que fuera capaz de jugar utilizando gramáticas, aunque fueran extremadamente primitivas. Pese a lo rudimentario y lo malo de los resultados iniciales, fue emocionante ver que Pac-Man se movía de una manera que no había especificado directamente nadie, sino que había determinado él como la mejor. La integración supuso básicamente que JECO lanzara un Pac-Man para evaluar cada uno de los árboles de derivación que producía pasados a formato string, Pac-Man le devolviera los puntos y JECO los interpretara como \textit{fitness}.

Como ya había que empezar a valorar qué gramáticas y mejoras eran mejor que otras, diseñé un sistema de logs de \textit{fitness} también bastante rudimentario, mientras se habilitó multithread y la GUI iba tomando forma en gran parte gracias a Héctor.

Luego me puse a tratar de mejorar la eficacia de este primer sistema rudimentario, sobretodo con la ayuda de José Miguel, para conseguir darle forma de autómata que tuviera en cuenta ciertos factores del estado del juego, e incluso conseguimos integrar con él evaluaciones condicionales.

Tras esto decidimos ``ponernos serios'' e implementar árboles de decisión en condiciones, pudiendo introducir símbolos en la gramática que representaran llamadas a funciones de consulta del estado de juego, y en función del resultado optar por una rama u otra del árbol. Fue interesante pensar el diseño de implementación con Héctor y José Miguel, y posteriormente ayudar un poco a José Miguel en la implementación final.

Una vez tuvimos los andamios de la estructura definitiva ya implementados, me puse a crear funciones de Pac-Man con los compañeros para que la gramática pudiera consultarlas y obtener información del juego o movimientos directos.

Siguiendo con las mejoras estructurales, cree un sistema que recopilaba información diversa de cada partida jugada, de forma que la función de \textit{fitness} recibe un objeto con ella y puede tener en cuenta lo que le interese para evaluar. Este fue el comienzo de lo que luego sería el multi-objetivo.

También implementé un log mucho más interesante que el rudimentario inicial, que guardaba mucha más información de las ejecuciones realizadas desde JECO y sus mejores resultados, en formato \texttt{csv}. Dicho log luego incluiría incluso una comunicación con git utilizando la librería \textit{JGit}, que permitiría registrar el \textit{commit} con el que se realizó la ejecución, para no mezclar resultados de una y otra versión del proyecto.

Por último mencionar la implementación de \textit{Neutral Mutation}, un operador de mutación específico para gramáticas evolutivas que ayuda a dar diversidad a la población. 

Faltan un montón de cosas menos significativas que fueron ocurriendo entre todo esto, pero en definitiva: Un montón de trabajo tanto en líneas código como en investigación, debates de implementación, trabajo en equipo y un proyecto que al menos a mi me ha resultado muy interesante y me ha hecho aprender muchísimo sobre inteligencia artificial, programación genética y gramáticas evolutivas, y conocer más a tres muy buenos compañeros con los que ha sido un placer trabajar.
