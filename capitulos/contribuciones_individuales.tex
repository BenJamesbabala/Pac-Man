\chapter{Contribuciones individuales}

\section{Héctor Laria Mantecón}
Decidir la versión de Pac-Man a utilizar fue bastante fácil ya que nuestro profesor Antonio nos recomendó una con bastantes buenas referencias, así que pudimos jugar todos en verano con ella para volvernos familiares. Cuando empezó el curso buscamos el \textit{framework} de Programación Evolutiva, probando primeramente con GEVA. Ninguno consiguió hacerlo funcionar porque usaba tecnología un poco obsoleta y era algo oscuro. Así que nuestro profesor Carlos nos presentó una segunda opción en la que estábamos de acuerdo los cuatro, JECO. Ésta era más simple, versátil y mejor organizada así que aunque todos hemos tenido que pelear y modificarla en algún momento, nos ha sido de mucha utilidad.

Teniendo eso resuelto, lo primero que hice fue encargarme del repositorio de código ya que yo era un poco más familiar con el uso de herramientas de versionado, desarrollo en ramas, \textit{issues}, uso de etiquetas y versiones, etc. Puse a disposición de los demás algunas páginas en la \textit{wiki} del repositorio sobre cómo borrar y fusionar ramas y demás. Tampoco fue la panacea, ya que aprendimos a las malas que el desarrollo paralelo es mejor dividirlo por \textit{features}, no por personas.

Una vez dominado y debido al buen funcionamiento que llevábamos, pensamos en ir un poco más allá y buscar una herramienta de gestión de proyectos más avanzada y que tuviera integración con nuestro repositorio de \textit{GitHub}. Sobre todo porque en ese momento había ciertas tareas que requerían de otras y no queríamos dejar a gente parada. Busqué e hice comparación de herramientas sobre todo con diagramas de \textit{Gantt} y encontré algunas pero de todas las que había no había ninguna que no fuese de pago. Al final llegó un momento en que tuvimos material suficiente como para que ninguno tuviese que estar esperando y dejamos la idea de estas herramientas a un lado.

En lo referente a la implementación, después de que Jorge Vieira conectara la versión del autómata con Pac-Man conseguí junto a él activar el multihilo para el algoritmo evolutivo y nos quedamos impresionados por el rendimiento que nos daba, ahora podíamos hacer uso de operadores más complejos y aumentar el tamaño de la evolución tardando incluso menos tiempo.

Más tarde, añadí soporte para funciones de \textit{fitness} en JECO para mayor modularidad y que nos fuera más fácil cambiar entre funciones, con vistas al futuro.

Cuando terminamos el autómata estaba claro que necesitábamos una definición mejor de gramática y una conexión mejor con la ejecución en Pac-Man. Era el único que no había dado fundamentos ni procesamiento de lenguaje, así que me propuse investigar y aprender sobre gramáticas, sacando al final la llamada gramática base. A la que además le pude meter las funciones en las que estaban trabajando los demás. Cuando la terminé tuvo muy buena aceptación y me dieron \textit{feedback} para pulir ciertos detalles. Estoy muy contento con esa gramática porque es muy robusta y bien organizada, así que nos sirvió como base para todas las siguientes gramáticas que se hicieron, cumpliendo totalmente mi objetivo.

Después de que José Miguel implementara los árboles de decisión que íbamos a usar para ejecutar el controlador de Pac-Man, me ocupé de que JECO derivara programas de la gramática base para después pasar el string producido al constructor de árboles José Miguel. Corregimos los fallos que nos daba el \textit{parseo} y así finalmente habíamos conectado JECO con los árboles de derivación.

Seguidamente, hice el código para ejecutar esos árboles en Pac-Man y que devolvieran un movimiento cada vez que se le pedía desde el juego, cerrando así el círculo con el algoritmo evolutivo, al conectar los árboles de derivación con Pac-Man. Más tarde esta parte sería reescrita para usar una nueva implementación de árbol más clara.

Paralelamente al desarrollo del trabajo, me ocupé en solitario de crear una interfaz gráfica que fuera sencilla y cubriera todas nuestras necesidades. Si tuviera que hacerla de nuevo me negaría en rotundo a hacerla yo solo, lo distribuiríamos entre dos o entre los cuatro. Tuve la suerte de empezar en vacaciones de navidad pero fue un trabajo demasiado grande, tanto como para empezar como para mantenerla y actualizarla.

Tuve que modificar los algoritmos de JECO, los patrones que implementaba, hacer una arquitectura entera para hablar con todas las partes, investigar la librería gráfica de Java para que no se bloqueara la interfaz al evolucionar, además conseguir que el multiobjetivo siguiera funcionando a la vez, investigar librerías de dibujado de gráficas, investigar la implementación de Pac-Man para incrustar su ventana en la interfaz, sin que se bloqueara tampoco al ejecutar una partida ni al estar evolucionando, y un largo etcétera de problemas que surgieron más adelante.
En los últimos meses estaba tan ocupado que José Miguel me echó una mano para añadir ciertos detalles, como el selector de \textit{fitness} multiobjetivo.

Después de terminar los árboles llegó la hora de empezar a experimentar con multiobjetivo. Después de consultar y ver que JECO tenía soporte y los operadores necesarios para ello, me dispuse a mejorar la primera versión del soporte de \textit{fitness} que había hecho antes para que soportara varios \textit{fitness} a la vez, pasándole a JECO los resultados fácilmente.
En los últimos meses, gracias al sistema gestor de recursos que hizo Jorge Vieira pude tener suficientes datos para hacer varios análisis de los entrenamientos, además de sacar gráficas y estadísticas tanto para el artículo como la memoria. Usé \textit{Jupyter Notebook} y las librerías \textit{Pandas} y \textit{Seaborn} para ello.

Siguiendo con los análisis, debido a la naturaleza estocástica de los controladores de los fantasmas, necesitábamos tantos datos como fuera posible para paliar este efecto y poder hacer mediciones correctas. Por lo que hice un \textit{script} que corría miles de partidas y guardaba los datos. José Miguel me ayudó a manejar los datos y conseguimos las medidas de los mejores elementos de las evoluciones, con mucho mayor detalle que en el entrenamiento.

En definitiva, he aprendido mucho con este trabajo. Cómo trabajar en equipo (mucho más que en la carrera), cómo hacer las cosas, cómo no hacerlas, lo fácil que es acostumbrarse al buen trabajo de los compañeros y más. También he aumentado mis conocimientos Programación Evolutiva y, por lo menos yo, le he cogido el gusto a leer artículos de investigación.

\section{Jorge Sánchez Cremades}
Nuestro profesor Antonio antes de comenzar el curso nos facilitó el código de una versión del juego Pac-Man que es utilizada normalmente en competiciones y desarrollo de Inteligencia Artificial. Durante el verano tuvimos tiempo de experimentar con esta versión y ver su funcionamiento interno (controladores de Pac-Man, controladores de Fantasmas, modos de ejecución del juego, lógica interna, etc.) y pensar cómo se podría adaptar para su uso en un algoritmo evolutivo.

Debido a mi estancia Erasmus+ durante el primer cuatrimestre no tuve una comunicación directa con mis compañeros y no pude asistir a las reuniones que mantenían con nuestros profesores por lo que durante este cuatrimestre estuve un poco más al margen y realice, en su mayoría, trabajos de investigación sobre artículos que nuestro profesor Carlos me enviaba o subía a una carpeta en Google Drive compartida. Empecé desarrollando un lector de gramáticas escritas en BNFs dado que muy al principio teníamos en mente implementar desde cero todo el algoritmo de evolución gramatical pero, por recomendación de los profesores, decidimos investigar frameworks ya hechos como GEVA y JECO. GEVA no fue de nuestro agrado desde el principio por lo que nos decantamos por JECO que es mucho más simple, estructurado y está desarrollado por varios profesores de nuestra universidad y esto nos permitiría consultarles dudas en caso de tenerlas. A partir de ahí mi contribución fue meramente de investigación durante el resto del cuatrimestre o de testeo y análisis de las primeras implementaciones en JECO.

A la vuelta de mi estancia Erasmus+ ya podía participar en persona y tuve una contribución más directa. Durante el desarrollo e implementación de los árboles de decisión por parte de José Miguel, implementé junto a mis compañeros parte de las funciones de obtención de información del estado de juego para su uso en las gramáticas a desarrollar.

Con la finalización de los árboles de decisión ya se observaron comportamientos interesantes pero no los esperados. Por ello, me encargue de hacer una implementación y estudio de nuevas BNFs de bajo y medio nivel a partir de la gramática base de Hector. Este proceso consistió en el desarrollo de una gramática inicial de bajo y otra de medio nivel y ver sus resultados (bots desarrollados, funciones que se usan, estructura de los fenotipos, etc.) y a través de estos resultados el desarrollo de nuevas versiones mejoradas hasta que obtuve las actuales gramáticas utilizadas de bajo y medio nivel.
Con las nuevas gramáticas nos centramos más en ver el comportamiento general del algoritmo. Nos dimos cuenta de un comportamiento poco común en las gráficas de evolución obtenidas (muy uniformes, sin mostrar diversidad entre generaciones en el fitness medio) que no tenían la forma típica de las gráficas en los algoritmos evolutivos (menos uniformes con variaciones notables entre los fitness medios de distintas generaciones) así que me dispuse a analizar el código de JECO y descubrí que implementa un método poco convencional e incorrecto de generar la nueva población para la siguiente generación por lo que implemente una versión distinta y típica en los algoritmos genéticos y que soportara el uso de elitismo lo que provocó una mejora en el rendimiento general del algoritmo y la aparición de las gráficas esperadas. A continuación, realicé un estudio de resultados obtenidos ejecutando evoluciones con distintos operadores y mecanismos de selección, cruce y mutación con el fin de detectar la mejor combinación. Este estudio no aportó nada significativo debido a la similaridad de los resultados obtenidos pero pudimos ver que todas las gráficas obtenidas mostraban un comportamiento poco convergente y, por recomendación de nuestro profesor Carlos, decidimos implementar nuevos operadores de cruce y mutación.

La implementación del cruce LHS la realicé a partir de un artículo investigado. La implementación como tal no fue difícil pero el estudio de resultados y la búsqueda de posibles errores fue un poco más laborioso. Durante este estudio descubrí que gran parte de los codones del genotipo de los individuos no eran utilizados a la hora de generar el fenotipo y realicé otro estudio sobre el uso de los codones descubriendo que, en efecto, normalmente sólo un 10\% de los codones era utilizado a la hora de generar los distintos fenotipos.

Por último, realice un pequeño cambio en la implementación multiobjetivo de JECO el cual no utilizaba en su totalidad el algoritmo NSGA-II, utilizando una mezcla entre el NSGA-II y otro denominado MOGA. El cambio supuso el uso único y correcto del algoritmo NSGA-II.
 
Ha sido un placer trabajar al lado de mis compañeros y les agradezco su ayuda y comprensión durante mi estancia Erasmus+ que no me permitió ayudarles al cien por cien. Aun así siempre ha habido un gran compañerismo entre nosotros y todos han estado dispuestos a ayudar a otro en cualquier momento. También cabe destacar la realización de un artículo académico en conjunto y que con otro grupo no hubiese sido posible.


\section{José Miguel Tajuelo Garrigós}
Durante el verano previo al proyecto acordamos intentar codificar un bot de Pac-Man cada uno de los integrantes del proyecto, para poder extraer algunas ideas del experimento. Una vez ya iniciado el Trabajo de Fin de Grado, ayude a mis compañeros a decidir qué framework usar, analizando y realizando pruebas con GEVA, hasta optar final por descartar y emplear JECO en su lugar. Una vez que Jorge Vieira logró integrar Ms. Pac-Man vs. Ghosts, le ayude a implementar el primer bot experimental que ejecutaba cadenas de caracteres, centrándome principalmente en el diseño de un mecanismo de condicionales (y su implementación), optimizaciones y mejoras de algunas funciones (como la mejora de una función de huida básica), y traza de algunos errores y comportamientos anómalos (como la necesidad de un reseteo del punto de entrada al comienzo de cada vida).
 
En la segunda fase del proyecto realice la implementación de árboles de decisión, empleando enumerados para los símbolos de la gramática (lo simplifica mucho la tarea de añadir nuevas funciones que consulten el estado y acciones), con condicionales con operadores numéricos y booleanos, y con una función de evaluación recursiva. Además, implementa un traductor (parser) que construye estos árboles a partir de un string con el código. Además, ayude a Héctor con un método que pasase el árbol a string de forma legible para cualquier usuario (en forma de código convencional), además de implementar método que “limpie” el string de código embellecido (o no) a un string si parseable.
 
Una vez completada la implementación de árboles de decisión, añadí, al igual que el resto de mis compañeros, algunos símbolos para tener, requiriendo implementación de nuevas funciones internas en el código de Ms. Pac-Man vs. Ghosts, así como ayudar a Jorge Vieira a mejorar la eficiencia de las funciones que más tiempo consumen. Después, también revise que todas las funciones implementadas hasta ese momento realizasen el comportamiento esperado, y no hubiera ningún error imposible de trazar, descubriendo algunas erratas, funciones que no realizaban lo esperado y algunos fallos de eficiencia. Entre ellas se encuentra el cálculo de distancias a fantasmas no comibles, que supuso su implementación, ya que en lugar de calcular la distancia teniendo en cuenta la imposibilidad de los fantasmas de darse la vuelta, la calculaba aplicándole erróneamente ese handicap a Pac-Man. Por otro lado, también añadió un nuevo fitness basado en el número de niveles completados.
 
Simultáneamente ayude a Héctor con distintos aspectos de la Interfaz Gráfica. Primero de todo, realice el diseño e implementación del selector de objetivos a perseguir, partiendo del concepto de una ventana emergente (para evitar saturar el panel de ajustes del experimento) en la que poder seleccionar y deseleccionar elementos de una lista. Esto lo logre creando personalizada una lista (de interfaz gráfica) que sobreescribe parte de sus métodos. También realice una reorganización experimental de los elementos del panel de ajustes, revirtiendo los cambios al final. También realicé, con la ayuda de Héctor, numerosos cambios internos para permitir el escalado de la pantalla del juego para una visualización más clara.
 
Finalmente, para la obtención de datos concretos sobre el rendimiento del proyecto, ayude a Héctor con el tratamiento de datos obtenido a partir de tanto la ejecución normal como la ejecución del Batch Executor.


\section{Jorge Vieira Luna}
Cuando tuvimos claro el proyecto lo primero fue buscar junto a los compañeros los \textit{frameworks} que íbamos a usar, tanto para Pac-Man como para JECO. Decantarse por ``Ms. Pac-Man Vs. Ghost'' para Pac-Man fue fácil: Ha habido varias versiones, pero la única que se mantiene actualizada y para la que se hacen competiciones a día de hoy es esa.

El \textit{framework} de gramáticas evolutivas en cambio no estaba tan claro. Primero probamos bastante GEVA, tal vez por ser de los más famosos, pero personalmente no me gustó nada la estructura del código con vistas a integrarlo con Pac-Man. Sin embargo cuando tras leer y trastear con el código de JECO para mi estaba claro, con JECO no iba a haber problemas, así que fuí partidario de JECO que es lo que usamos al final. Hemos tenido sus más y sus menos con él, pero personalmente yo y creo que mis compañeros estamos bastante contentos con la decisión.

Una vez que tuvimos los \textit{frameworks} me ocupé de la integración entre ambos, para conseguir una primera versión que fuera capaz de jugar utilizando gramáticas, aunque fueran extremadamente primitivas. Pese a lo rudimentario y lo malo de los resultados iniciales, fue emocionante ver que Pac-Man se movía de una manera que no había especificado directamente nadie, sino que había determinado él como la mejor. La integración supuso básicamente que JECO lanzara un Pac-Man para evaluar cada uno de los árboles de derivación que producía pasados a formato string, Pac-Man le devolviera los puntos y JECO los interpretara como \textit{fitness}.

Como ya había que empezar a valorar qué gramáticas y mejoras eran mejor que otras, diseñé un sistema de logs de \textit{fitness} también bastante rudimentario, mientras se habilitó multithread y la GUI iba tomando forma en gran parte gracias a Héctor.

Luego me puse a tratar de mejorar la eficacia de este primer sistema rudimentario, sobretodo con la ayuda de José Miguel, para conseguir darle forma de autómata que tuviera en cuenta ciertos factores del estado del juego, e incluso conseguimos integrar con él evaluaciones condicionales.

Tras esto decidimos ``ponernos serios'' e implementar árboles de decisión en condiciones, pudiendo introducir símbolos en la gramática que representaran llamadas a funciones de consulta del estado de juego, y en función del resultado optar por una rama u otra del árbol. Fue interesante pensar el diseño de implementación con Héctor y José Miguel, y posteriormente ayudar un poco a José Miguel en la implementación final.

Una vez tuvimos los andamios de la estructura definitiva ya implementados, me puse a crear funciones de Pac-Man con los compañeros para que la gramática pudiera consultarlas y obtener información del juego o movimientos directos.

Siguiendo con las mejoras estructurales, cree un sistema que recopilaba información diversa de cada partida jugada, de forma que la función de \textit{fitness} recibe un objeto con ella y puede tener en cuenta lo que le interese para evaluar. Este fue el comienzo de lo que luego sería el multi-objetivo.

También implementé un log mucho más interesante que el rudimentario inicial, que guardaba mucha más información de las ejecuciones realizadas desde JECO y sus mejores resultados, en formato \texttt{csv}. Dicho log luego incluiría incluso una comunicación con git utilizando la librería \textit{JGit}, que permitiría registrar el \textit{commit} con el que se realizó la ejecución, para no mezclar resultados de una y otra versión del proyecto.

Por último mencionar la implementación de \textit{Neutral Mutation}, un operador de mutación específico para gramáticas evolutivas que ayuda a dar diversidad a la población. 

Faltan un montón de cosas menos significativas que fueron ocurriendo entre todo esto, pero en definitiva: Un montón de trabajo tanto en líneas código como en investigación, debates de implementación, trabajo en equipo y un proyecto que al menos a mi me ha resultado muy interesante y me ha hecho aprender muchísimo sobre inteligencia artificial, programación genética y gramáticas evolutivas, y conocer más a tres muy buenos compañeros con los que ha sido un placer trabajar.
